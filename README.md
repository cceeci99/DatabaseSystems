# Υλοποίηση Συστημάτων Βάσεων Δεδομένων
# Εργασία 2

## Προσωπικά Στοιχεία

Όνομα: Tsvetomir Ivanov Α.Μ.: 1115201900066

Όνομα: Χρήστος Γαλανόπουλος Α.Μ.: 1115201900031

## Documentation

## 1. Δομη Project και οδηγίες εκτέλεσης
...
  Στον φάκελο examples, όπου βρίσκεται η main του προγραμματος (sht_main.c), έχει προστεθεί ενα αρχειο επικεφαλίδας data.h το οποίο περιέχει πίνακες για names, surnames, cities με παραπάνω στοιχεία. Ετσι μπορεί να δοκιμαστεί το πρόγραμμα για μεγάλο πλήθος εγγραφών (ακόμη και για 1000). 
Ορίζονται επίσης οι σταθερές
- NO_RECORDS -> πλήθος εγγραφών που πρόκειται να εισαχθούν στα πρωτεύοντα αρχεία.
- GLOBAL_DEPTH -> αρχικό βάθος με το οποίο δημιουργούνται τα αρχεία
- INDEX_KEY -> 'city' or 'surname' , το πεδίο κλειδί στο οποίο θα δημιουργηθούν τα δευτερεύοντα αρχεία
- NO_NAMES
- NO_SURNAMES
- NO_CITIES

Οι τελευταίες τρεις, καθορίζουν το πλήθος των στοιχείων που θα ληφθουν υπόψιν κατα την εισαγωγή. Οσο μικρότερες οριστούν οι σταθερές, φαίνεται καλύτερο αποτέλεσμα για την InnerJoin μιας και το προγραμμα επιλέγει τυχαία με rand() το πεδίο πανω στο οποίο θα κάνει ζεύξη.

  Προσθήκη ενιαίου αρχείου επικεφαλίδας (header file):
- ht.h: Περιέχει τις κοινές δομές (Record, HF_Info:πίνακας ανοικτών αρχείων),  για πρωτεύον και δευτερεύον ευρετήριο.

## 2. Σχεδιαστικές επιλογές και παραδοχές

Ένα αρχείο δευτερεύοντος ευρετηρίου επεκτατού κατακερματισμού (SHT) περιέχει:

- 1 metadata block
- 1 ή παραπάνω hash blocks
- 2 ή παραπάνω data blocks

### a) Δομή metadata block

Ένα metadata block έχει την ακόλουθει δομή: 

- αναγνωρισιτκό του hash file -> 'HashFile'
- χαρακτήρας που καθορίζει σε ποιο πεδίο κλειδί δημιουργείται το δευτερεύον -> 'c' για city, 's' για surname
- τρέχον global depth
- αριθμός hash blocks
- id για το 1ο hash block
- id για το 2ο hash block
- ...

### b) Δομή hash block

Ένα hash block έχει την ακόλουθει δομή:

- bucket 0 που περιέχει ένα data block id
- bucket 1 που περιέχει ένα data block id
- ...

### c) Δομή data block

Ενα data block έχει την ακόλουθη δομή:

- τρέχον local depth
- αριθμός εγγραφών
- 1η εγγραφή
- 2η εγγραφή
- ...

Ο αριθμός των εγγραφών που χωράνε στο data block είναι δίνεται απο την σταθερά SECONDARY_BLOCK_CAP = 512-4/24 = 21 εγγραφές (24 ειναι το μέγεθος της δομης Secondary Record).

### Secondary Hash Table
Οπως και με το πρωτεύον ευρετήριο, το hash table είναι νοητό, εννοώντας ότι δεν υπάρχει κάποιο struct για την αναπαράστασή του αλλά συνίσταται από όλα τα hash blocks που περιέχουν τα buckets.

### Hash_Function
Το hash function δέχεται ως όρισμα το index-key μιας εγγραφής και κάνει καποιες κατάλληλες για συμοβολοσειρές ενέργειες κατακερματισμού επιστρέφοντας ενα string απο 14 χαρακτήρες ('0' και '1').
  
### HF_Info open_files: Πίνακας ανοικτών αρχείων
Χρησιμοποιείται ένας πίνακας χωρητικότητας 20, για αποθήκευση οποιονδήποτε ανοιχτών αρχείων, είτε ειναι πρωτευοντα ευρετήρια είτε δευτερεύοντα. Εχουν προστεθεί κάποια extra πεδία στο struct HF_Info:

- file descriptor
- τρέχον βάθος
- αριθμός εισαχθέντων εγγραφών
- τρέχον αριθμός κάδων
- τρέχον αριθμός hash blocks
- ονομα του αρχείου
- τύπος ευρετηρίου (πρωτεύον ή δευτερεύον)
- θεση στον πίνακα των ανοικτών αρχείων του αντίστοιχου αρχειου πρωτεύοντος ευρετηρίου πάνω στο οποίο εχει δημιουργηθεί ενα δευτερεύον
- τυπος κλειδιού (index-key) στην περίπτωση που ειναι δευτερεύον -> ('c' για city, 's' για surname)
- split -> χρησιμοποιείται για τον χειρισμό των split που μπορεί να προκύψουν σε ενα πρωτεύον ευρετήριο επηρεάζοντας ανάλογα το δευτερεύον

## 3. Ανάλυση λειτουργικότητας HT, SHT συναρτήσεων
 
### HT_Init, SHT_Init:
Επειδή η HT_Init αρχικοποιεί τον αδειο πίνακα open_files, η SHT_Init δεν χρειάζεται να κάνει καποια λειτουρία.

###  HT_InsertEntry:

#### Τροποποίηση πρότυπου συνάρτησης:
Το πρότυπο της συνάρτησης εισαγωγής εγγραφής στο πρωτεύον ευρετήριο εχει τροποποιηθεί ως εξης:
- αλλαγή του δεικτη σε δομη UpdateRecordArray σε διπλό, ώστε να ειναι δυνατή η τροποποιηση του πίνακα των δομων αυτών απο την συνάρτηση και η επιστροφή του στην συνάρτηση που την καλεί.
- προσθήκη επιπλέον ορίσματος, δείκτη σε ακεραιο που δηλώνει το μέγεθος του πίνακα updateArray, καθώς αυτος δημιουργείται δυναμικά με malloc στην HT_InsertEntry και πρέπει να είναι γνωστός.

#### Τροποποίηση λειτουργίας:
Η HT_InsertEntry κάνει τις κατάλληλες ενέργειες ώστε να επιστρέψει την θέση στην οποία εισήχθη μια νέα εγγραφή, και να φτιάξει σε περίπτωση split τον πίνακα updateArray ο οποίος αποθηκεύει τις εγγραφές που άλλαξαν μετά την διάσπαση των bucket.

### SHT_CreateSecondaryIndex:
Δημιουργεί ένα νέο αρχείο επεκτατού κατακερματισμού δευτερεύοντος ευρετηρίου με δοσμένο βάθος, πεδίο κλειδί πάνω στο οποίο θα γίνει η ευρετηρίαση, και όνομα του αντίστοιχου αρχείου πρωτεύοντος ευρετηρίου. Η υλοποίηση της είναι παρόμοια με αυτήν της κατασκευής του πρωτεύοντος,  με την μόνη διαφορά την προσθήκη της πληροφορίας για το πεδίο κλειδι στο metadata του αρχείου.

### SHT_OpenSecondaryIndex:
Ελέγχεται ότι το αρχείο προς άνοιγμα είναι ένα valid hash file με ορθό index-key, ενημερώνεται κατάλληλα ο πίνακας open_files ώστε να περιέχει τις πληροφορίες που χρειάζονται και επιστρέφεται η θέση του πίνακα στην οποία αποθηκεύτηκαν.

#### Σχόλιο: Επειδή ο πίνακας των ανοικτών αρχείων είναι global και επομένως γνωστός και στην main συνάρτηση, επιλέγεται η τελευταία να ενημερώσει όταν φτιαχτεί και ανοιχτεί το δευτερεύον, το πεδίο που δηλώνει την θέση του αντιστοιχου πρωτεύοντος αρχείου. Η παραδοχή αυτή γίνεται για να μην επιβαρύνεται με παραπάνω πληροφορίες το metadata block του δευτερεύοντος.

### SHT_CloseSecondaryIndex:
Κλείνει το ανοιχτό δευτερεύον hash file και ενημερώνεται με κατάλληλο τρόπο ο πίνακας open_files.

### SHT_SecondaryUpdateEntry:

#### Τροποποίηση πρότυπου συνάρτησης:
Προστίθεται ως όρισμα, ένας ακέραιος για το μέγεθος του πίνακα.

#### Λειτουργία:
Για ολες τις εγγραφές που έχουν αποθηκευτεί στον πίνακα updateArray, εκτελεί σειριακή αναζήτηση στο αρχείο του δευτερεύοντος ευρετηρίου, και αφου τις βρει ενημερώνει κατάλληλα τις αλλαγές που έγιναν.

### SHT_InnerJoin:
Η διαδικασία της ζεύξης υλοποιείται ως εξής:
Αν το πεδιο index_key δεν ειναι NULL αλλά κάποια πόλη ή επίθετο (π.χ Athens ή Ioannidis) τότε εκτελείται σειριακή αναζήτηση στο δευτερεύον του πρώτου αρχείου (sindexDesx1) και αφου βρεθεί η εγγραφή, αναζητούνται εγγραφές με το ιδιο πεδίο στο δευτερευον του δεύτερου αρχείου. Στην περίπτωση που υπάρχουν πανω απο μια εγγραφες στο πρώτο αρχείο θα εκτυπωθουν σε διαφορετικες γραμμες όλοι οι δυνατοί συνδυασμοι όπως στην παρακάτω εικόνα.
<img width="832" alt="Screenshot 2022-01-08 at 18 12 59" src="https://user-images.githubusercontent.com/61785341/148686500-69ee0f24-a4cb-4766-a819-f12095717eca.png">



Αν το πεδιο index_key είναι NULL, εκτελείται σειριακά η ιδια διαδικασία με την διαφορά οτι ως index_key λαμβάνεται καθε φορά το index_key απο τo κάθε record του δευτερεύοντος ευρετηρίου για το πρώτο αρχείο. Ετσι εκτυπώνονται σε διαφορετικες γραμμές όλες οι δυνατές ζεύξεις σε καποιο πεδίο για τα δύο αρχεία όπως στην παρακάτω εικόνα. 
<img width="718" alt="Screenshot 2022-01-09 at 16 26 13" src="https://user-images.githubusercontent.com/61785341/148686566-ca65f50d-3ee8-420b-a60e-76c4a2f928f3.png">
